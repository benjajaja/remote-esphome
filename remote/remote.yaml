substitutions:
  device_name: remote

esphome:
  name: ${device_name}-esphome

esp32:
  board: esp32doit-devkit-v1
  framework:
    type: esp-idf

# Enable logging
logger:

ota:
  - platform: esphome
    password: !secret ota_password

api:
  encryption:
    key: !secret api_encryption_key

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  domain: .lan

mqtt:
  broker: ops.lan
  port: 1883
  discovery: true
  discovery_retain: true
  discovery_unique_id_generator: mac
  birth_message:
    topic: ${device_name}-esphome/status
    payload: online
  will_message:
    topic: ${device_name}-esphome/status
    payload: offline

light:
  - platform: binary
    name: "WiFi Status LED"
    id: wifi_led
    output: led_output
    internal: true

output:
  - platform: gpio
    pin: GPIO2  # Change this to your LED pin
    id: led_output

# WiFi connection status automation.
interval:
  - interval: 5s
    then:
      - if:
          condition:
            wifi.connected:
          then:
            - light.turn_off: wifi_led
          else:
            - light.turn_on: wifi_led
 
remote_transmitter:
  pin: GPIO13
  carrier_duty_percent: 50%
  id: remote_tx

script:
  - id: transmit_house_code
    parameters:
      house: int
      code: int
    then:
      - lambda: |-
          // Use uint32_t to ensure we have enough bits
          uint32_t combined = ((uint32_t)house << 8) | (uint32_t)code;
          
          // Convert to 24-bit binary string
          std::string binary_str = "";
          for (int i = 23; i >= 0; i--) {
            if (combined & (1UL << i)) {
              binary_str += "1";
            } else {
              binary_str += "0";
            }
          }
          
          ESP_LOGD("house_code", "House: %d, Code: %d -> Combined: %lu -> Binary: %s", 
                   house, code, (unsigned long)combined, binary_str.c_str());
          
          id(binary_code) = binary_str;
      - remote_transmitter.transmit_rc_switch_raw:
          code: !lambda "return id(binary_code);"
          protocol:
            pulse_length: 400
            sync: [1, 31]
            zero: [1, 3]
            one: [3, 1]
          repeat:
            times: 5
            wait_time: 0s
  - id: codes_to_binary
    parameters:
      codes: string
    then:
      - lambda: |-
          // Clear previous codes
          id(binary_codes).clear();
          
          // Parse comma-separated string
          std::string codes_str = codes;
          std::string delimiter = ",";
          size_t pos = 0;
          std::string token;
          
          // Add trailing comma to catch last element
          codes_str += ",";
          
          while ((pos = codes_str.find(delimiter)) != std::string::npos) {
            token = codes_str.substr(0, pos);
            
            // Trim whitespace
            token.erase(0, token.find_first_not_of(" \t"));
            token.erase(token.find_last_not_of(" \t") + 1);
            
            if (!token.empty() && token[0] == '{') {
              // Parse format: {bits}code
              size_t close_brace = token.find('}');
              if (close_brace != std::string::npos) {
                std::string bits_str = token.substr(1, close_brace - 1);
                int bit_count = std::stoi(bits_str);
                std::string code_str = token.substr(close_brace + 1);
                
                // Parse hex code (assume hex without 0x prefix)  
                uint64_t parsed_code = std::stoull(code_str, nullptr, 16);
                
                // Find how many bits this code naturally has
                int natural_bits = 64 - __builtin_clzll(parsed_code);
                
                uint64_t code;
                if (natural_bits > bit_count) {
                  // Shift right to align properly
                  int shift = natural_bits - bit_count + 1;
                  code = parsed_code >> shift;
                  // Mask to ensure we only use the specified bit count
                  uint64_t mask = (1ULL << bit_count) - 1;
                  code = code & mask;
                } else {
                  code = parsed_code;
                }
                
                // Convert to binary string and apply inverse logic
                std::string binary = "";
                for (int i = bit_count - 1; i >= 0; i--) {
                  bool bit = (code >> i) & 1;
                  binary += bit ? "0" : "1";  // Apply inverse logic
                }
                
                // Store in global vector
                id(binary_codes).push_back(binary);

                // Log for debugging
                ESP_LOGD("transmit_codes", "Code: %s, Bits: %d, Parsed: 0x%llx, Binary: %s", 
                         code_str.c_str(), bit_count, code, binary.c_str());
              }
            }
            
            codes_str.erase(0, pos + delimiter.length());
          }
      - repeat:
          count: !lambda "return id(binary_codes).size();"
          then:
            - remote_transmitter.transmit_rc_switch_raw:
                code: !lambda "return id(binary_codes)[iteration];"
                protocol:
                  pulse_length: 104
                  sync: [1, 116]
                  zero: [4, 12]
                  one: [12, 4]
  # New script for Living Room Light Toggle using rc-switch directly
  - id: transmit_living_room_toggle

    then:
      - lambda: |-
          auto transmitter = id(remote_tx);
          
          // Timing constants - easy to adjust
          const uint32_t PULSE_LENGTH = 388;  // Try: 380, 388, 396, 400
          const uint32_t INTER_MSG_DELAY = 10; // milliseconds between transmissions
          
          // First transmission: 32-bit code "11010001111011111111100011000111"
          uint64_t code1 = 0b11010001111011111111100011000111ULL;
          
          auto call1 = transmitter->transmit();
          // RCSwitchBase(sync_high, sync_low, zero_high, zero_low, one_high, one_low, inverted)
          esphome::remote_base::RCSwitchBase custom_protocol(
            PULSE_LENGTH,      // sync_high: 1 * pulse_length
            PULSE_LENGTH * 30, // sync_low: 30 * pulse_length  
            PULSE_LENGTH * 3,  // zero_high: 3 * pulse_length
            PULSE_LENGTH * 1,  // zero_low: 1 * pulse_length
            PULSE_LENGTH * 1,  // one_high: 1 * pulse_length
            PULSE_LENGTH * 3,  // one_low: 3 * pulse_length
            false              // not inverted
          );
          custom_protocol.transmit(call1.get_data(), code1, 32);
          
          // Second transmission: 33-bit code "011010001111011111111100011000111" (repeated twice)
          uint64_t code2 = 0b011010001111011111111100011000111ULL;
          
          auto call2 = transmitter->transmit();
          custom_protocol.transmit(call2.get_data(), code2, 33);
          
          auto call3 = transmitter->transmit();
          custom_protocol.transmit(call3.get_data(), code2, 33);

          ESP_LOGI("living_room", "Transmitting first code: 0x%llX (32 bits)", code1);
          ESP_LOGI("living_room", "Transmitting second codes: 0x%llX (33 bits, 2x)", code2);
          
          // Perform transmissions with delays
          call1.perform();
          // delay(INTER_MSG_DELAY);
          call2.perform();
          // delay(INTER_MSG_DELAY);
          call3.perform();

globals:
  - id: binary_code
    type: std::string
    initial_value: '""'
  - id: binary_codes
    type: std::vector<std::string>
    restore_value: no

button:
  # Bedroom 1
  - platform: template
    name: "Bedroom 1 Light On"
    id: ${device_name}_ceiling_fan_light_on
    on_press:
      - script.execute:
          id: transmit_house_code
          house: 13785
          code: 4
  - platform: template
    name: "Bedroom 1 Light Off"
    id: ${device_name}_ceiling_fan_light_off
    on_press:
      - script.execute:
          id: transmit_house_code
          house: 13785
          code: 1
  # - platform: template
    # name: "ON BLUE"
    # on_press:
      # - script.execute:
          # id: transmit_house_code
          # house: 13785
          # code: 6
  - platform: template
    name: "Bedroom 1 Fan 1"
    id: ${device_name}_ceiling_fan_1
    on_press:
      - script.execute:
          id: transmit_house_code
          house: 13785
          code: 10
  - platform: template
    name: "Bedroom 1 Fan 2"
    id: ${device_name}_ceiling_fan_2
    on_press:
      - script.execute:
          id: transmit_house_code
          house: 13785
          code: 7
  # - platform: template
    # name: "FAN 3"
    # on_press:
      # - script.execute:
          # id: transmit_house_code
          # house: 13785
          # code: 5
  # - platform: template
    # name: "FAN 4"
    # on_press:
      # - script.execute:
          # id: transmit_house_code
          # house: 13785
          # code: 9
  # - platform: template
    # name: "FAN 4"
    # on_press:
      # - script.execute:
          # id: transmit_house_code
          # house: 13785
          # code: 9
  # - platform: template
    # name: "FAN 5"
    # on_press:
      # - script.execute:
          # id: transmit_house_code
          # house: 13785
          # code: 12
  # - platform: template
    # name: "FAN 6"
    # on_press:
      # - script.execute:
          # id: transmit_house_code
          # house: 13785
          # code: 11
  - platform: template
    name: "Bedroom 1 Fan Off"
    id: ${device_name}_ceiling_fan_off
    on_press:
      - script.execute:
          id: transmit_house_code
          house: 13785
          code: 8
  - platform: template
    name: "Bedroom 1 Fan 2 Hours"
    id: ${device_name}_ceiling_fan_2_hours
    on_press:
      - script.execute:
          id: transmit_house_code
          house: 13785
          code: 18
  - platform: template
    name: "Bedroom 2 Light On"
    on_press:
      - script.execute:
          id: transmit_house_code
          house: 63258
          code: 4
  - platform: template
    name: "Bedroom 2 Light Off"
    on_press:
      - script.execute:
          id: transmit_house_code
          house: 63258
          code: 1
  - platform: template
    name: "Bedroom 2 Fan Off"
    on_press:
      - script.execute:
          id: transmit_house_code
          house: 63258
          code: 8
  - platform: template
    name: "Bedroom 2 Fan 1"
    on_press:
      - script.execute:
          id: transmit_house_code
          house: 63258
          code: 10
  - platform: template
    name: "Bedroom 2 Fan 2"
    on_press:
      - script.execute:
          id: transmit_house_code
          house: 63258
          code: 7
  - platform: template
    name: "Bedroom 2 Fan 3"
    on_press:
      - script.execute:
          id: transmit_house_code
          house: 63258
          code: 5
  - platform: template
    name: "Living Room Light Toggle"  
    id: ${device_name}_ceiling_fan_light_toggle
    on_press:
      - light.turn_on: wifi_led
      # - script.execute:
          # id: codes_to_binary
          # codes: '{32}d1eff8c7, {33}68f7fc6380, {33}68f7fc6380'
      - light.turn_on: wifi_led
      - logger.log:
          format: "SENDING RAW CODES"
          level: INFO
      - repeat:
          count: 5
          then:
            - script.execute: transmit_living_room_toggle
      # - remote_transmitter.transmit_rc_switch_raw:
          # code: "11010001111011111111100011000111"
          # protocol:
            # pulse_length: 388
            # sync: [1, 30]
            # zero: [3, 1]
            # one: [1, 3]
          # repeat:
            # times: 1
            # wait_time: 0ms
      # - remote_transmitter.transmit_rc_switch_raw:
          # code: "011010001111011111111100011000111"
          # protocol:
            # pulse_length: 388
            # sync: [1, 30]
            # zero: [3, 1]
            # one: [1, 3]
          # repeat:
            # times: 2
            # wait_time: 0ms
      - light.turn_off: wifi_led
      - delay: 500ms
      - light.turn_on: wifi_led
      - delay: 500ms
      - light.turn_off: wifi_led

# # # # #
# Total count:   98,  width: 178.86 ms		(44714 S)
# Pulse width distribution:
 # [ 0] count:   63,  width:  396 us [388;416]	(  99 S)
 # [ 1] count:   35,  width: 1200 us [1192;1216]	( 300 S)
# Gap width distribution:
 # [ 0] count:   60,  width: 1216 us [1204;1236]	( 304 S)
 # [ 1] count:   35,  width:  412 us [400;432]	( 103 S)
 # [ 2] count:    2,  width: 12132 us [12132;12136]	(3033 S)
# Pulse period distribution:
 # [ 0] count:   95,  width: 1612 us [1604;1640]	( 403 S)
 # [ 1] count:    2,  width: 12528 us [12528;12528]	(3132 S)
# Pulse timing distribution:
 # [ 0] count:   98,  width:  400 us [388;432]	( 100 S)
 # [ 1] count:   95,  width: 1208 us [1192;1236]	( 302 S)
 # [ 2] count:    3,  width: 12144 us [12132;12164]	(3036 S)
# Level estimates [high, low]:  15889,      2
# RSSI: -0.1 dB SNR: 39.0 dB Noise: -39.1 dB
# Frequency offsets [F1, F2]:    9164,      0	(+35.0 kHz, +0.0 kHz)
# Guessing modulation: Pulse Width Modulation with multiple packets
# view at https://triq.org/pdv/#AAB0280301019004B82F70818190819090908181818190818181818181818181909090818190909081818255+AAB0290302019004B82F7090818190819090908181818190818181818181818181909090818190909081818255
# Attempting demodulation... short_width: 396, long_width: 1200, reset_limit: 12140, sync_width: 0
# Use a flex decoder with -X 'n=name,m=OOK_PWM,s=396,l=1200,r=12140,g=1240,t=322,y=0'
# [pulse_slicer_pwm] Analyzer Device
# codes     : {32}d1eff8c7, {33}68f7fc638, {33}68f7fc638
# binary:
#  00101110000100000000011100111000
# 100101110000100000000011100111000
# 100101110000100000000011100111000
# inverted:
#  11010001111011111111100011000111
# 011010001111011111111100011000111
# 011010001111011111111100011000111

